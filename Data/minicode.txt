#include <stdio.h>
#include "arm_math.h"
#include "file_reader.h"
#include "file_writer.h"
#include "filters/iir.h"
#include "filters/kalman.h"
#include "angles.h"

#define DELTA_TT 0.04f

// Объявление массива для матрицы F размером 4x4
static const float32_t F_data[16] = {
      1.0f, 0.0f,  (-DELTA_TT),   0.0f,
      0.0f,  1.0f, 0.0f,   (-DELTA_TT),
      0.0f,  0.0f,  1.0f, 0.0f,
      0.0f,  0.0f,  0.0f,   1.0f
    };

// Объявление массива для матрицы R размером 2x2
static const float32_t R_data[4] = {
        0.0007f, 0.0f,
        0.0f,    0.0009f
};

// Объявление матрицы F размером 4x4
static const arm_matrix_instance_f32 F = {4, 4, (float32_t *)F_data};
// Объявление матрицы R размером 2x2
static const arm_matrix_instance_f32 R = {2, 2, (float32_t *)R_data};

typedef struct {
    // Матрицы, которые не изменяются
    const arm_matrix_instance_f32 *F;  // Матрица динамики системы
    const arm_matrix_instance_f32 *R;  // Матрица ковариации шума измерения
    
} KalmanFilter_t;

void kalman_init(KalmanFilter_t *kf) {
    // Присваиваем указатели на статические матрицы
    kf->F = &F;
    kf->R = &R;
}


int main() {
    KalmanFilter_t kf;
    kalman_init(&kf);
    //
    printf("Kalman Test\n");
    print_matrix(kf.F, "F");
    print_matrix(kf.R, "R");

    float32_t input_data[2] = {1.0f, 2.0f}; // Пример входных данных
    float32_t result_data[2] = {0};

    arm_matrix_instance_f32 input_vec = {2, 1, input_data};
    arm_matrix_instance_f32 result = {2, 1, result_data};

    // Умножение матрицы на вектор
    arm_status status = arm_mat_mult_f32(&R, &input_vec, &result);
    // Умножение матрицы на вектор
    arm_mat_vec_mult_f32(&R, &input_data, &result_data);

    print_matrix(&result);
    print_vector(&result_data, 2);

-- norm
    arm_mat_mult_f32(kf.F, kf.Q, &fq);
    print_matrix(&fq, "FQ");

    // Инициализация коллекции данных
    //
    printf("startNEW\n");
    DataCollection dataCollection;
    initDataCollection(&dataCollection, 10); // Начальная емкость 10

    // Чтение данных из файла
    int readResult = readDataFile(&dataCollection);
    // Открываем файл для записи результатов
    FILE *outputFile = fopen(OUTPUT_FILE, "w");
    // write Title and average value
    // усредняяем здесь первые значения для исходных данных.
    DataEntry dataAverage = file_writer_title(outputFile, &dataCollection);
    IIRFilter iir;
    initialFilter (&iir, &dataAverage);

    /* KalmanFilter kf; //  */
    /* Acceleration avg_acc = convertToAcceleration(&dataAverage); */
    /* Mag avg_mag = convertToMag(&dataAverage); */
    /* Angles avg_angles = calculateAngles(&avg_acc); */
    /* #<{(|  |)}># */
    /* Kalman_Init(&kf, avg_angles.pitch, avg_angles.roll); */
    /*  */

    // Для каждой строки входного файла выполняем расчеты и записываем в файл
    for (int i = MAX_AVERAGE_SAMPLES; i < dataCollection.count; i++) {
      // сырые данные
        Mag mag = convertToMag(&dataCollection.entries[i]);
        Acceleration acc = convertToAcceleration(&dataCollection.entries[i]);
        Angles pitchRoll = calculateAngles(&acc);
        float32_t azimuth = calculateAzimuth(pitchRoll.pitch, pitchRoll.roll, &mag);
        
// iir фильтр
        DataEntry data_i = filterStep (&iir,&dataCollection.entries[i]);
        Mag iir_mag = convertToMag(&data_i);
        Acceleration iir_acc = convertToAcceleration(&data_i);
        Angles iir_pitchRoll = calculateAngles(&iir_acc);
        float32_t iir_azimuth = calculateAzimuth(iir_pitchRoll.pitch, iir_pitchRoll.roll, &iir_mag);
        
// Kalman фильтр
        /* float32_t kalman_pitch, kalman_roll; */
        /* Kalman_GetAngles(&kf, &kalman_pitch, &kalman_roll); */
        /* #<{(| printf("%.2f %.2f \t ", kalman_pitch, kalman_roll); |)}># */
        /*  */
        /* const float32_t sin_tettha, cos_tettha; */
        /* arm_sin_cos_f32(kalman_pitch, &sin_tettha, &cos_tettha); */
        /* const float32_t sin_phi, cos_phi; */
        /* arm_sin_cos_f32(kalman_roll, &sin_phi, &cos_phi); */
        /*  */
        /* Gyro gyro = convertToGyro(&dataCollection.entries[i]); */
        /*  */
        /* float32_t wE = gyro.y * cos_phi - gyro.z * sin_phi; // градус в секунду */
        /* float32_t wN = gyro.x * cos_tettha + sin_tettha * (gyro.z * cos_phi + gyro.y * sin_phi); // градус в секунду */

        /* printf("we and wn : %.2f %.2f\t ", wE, wN); */
        /* printf("%.2f %.2f  %.2f\n", gyro.x, gyro.y, gyro.z); */
        /* // Прогноз Калмана */
        /* Kalman_Predict(&kf, DELTA_TT, wN, wE); */
        /*  */
        /* // Обновление Калмана */
        /* Kalman_Update(&kf, pitchRoll.pitch, pitchRoll.roll); */
        /*  */
        /* // Получение отфильтрованных углов */
        /* Kalman_GetAngles(&kf, &kalman_pitch, &kalman_roll); */

        /* float32_t kalman_azimuth = calculateAzimuth(kalman_pitch, kalman_roll, &iir_mag); */
        /* printf(" :: %.2f %.2f \n ", kalman_pitch, kalman_roll); */

        /* fprintf(outputFile, "%6.1f\t%15.10f\t%15.10f\t%15.10f\t%15.10f\t%15.10f\t%15.10f\t%15.10f\t%15.10f\t%15.10f\n", */
        /*         dataCollection.entries[i].time, */
        /*         pitchRoll.pitch, */
        /*         pitchRoll.roll, */
        /*         azimuth, */
        /*         kalman_pitch, */
        /*         kalman_roll, */
        /*         kalman_azimuth, */
        /*         iir_pitchRoll.pitch, */
        /*         iir_pitchRoll.roll, */
        /*         iir_azimuth); */

    }
    // Закрываем файл
    fclose(outputFile);
    printf("\nРезультаты успешно записаны в файл: %s\n", OUTPUT_FILE);
    
    // Освобождаем память
    freeDataCollection(&dataCollection);
    return 0;
}

void print_matrix(const arm_matrix_instance_f32 *m, const char *name) {
    printf("Matrix %s (%dx%d):\n", name, m->numRows, m->numCols);
    for (uint16_t i = 0; i < m->numRows; ++i) {
        for (uint16_t j = 0; j < m->numCols; ++j) {
            printf("%10.6f ", m->pData[i * m->numCols + j]);
        }
        printf("\n");
    }
    printf("\n");
}

void print_vector(const float32_t *vec, uint32_t size) {
    for(uint32_t i = 0; i < size; ++i) {
        printf("%10.6f ", vec[i]);
    }
    printf("\n");
}
